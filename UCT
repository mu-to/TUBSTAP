using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Threading;



namespace SimpleWars
{
    //UCT saerch
    class AI_myUCT : Player
    {
        // パラメータ
        private const int MAX_SIM = 2000;
        private const int SIM_SIKI = 10;     //5, 20, 40, 60
        private const double UCB_CONST = 0.3;

        // static変数
        private static int dev_num;
        private static int totalsim;
        private static int max_depth;
        private static int lastid;
        private static Map basemap;

        // AIの表示名を返す（必須）
        // 改行文字 \r, \n，半角大カッコ [, ]，システム文字は使わないでください．
        public string getName()
        {
            return "myUCT";
        }

        // パラメータ等の情報を返す（必須だが，空でも良い）
        // 改行は含んでも構いません．半角大カッコ [, ], システム文字は使わないでください．
        public string showParameters()
        {
            return "";

            // 例えば PARAM1, PARAM2 というパラメータがあって，棋譜等に残したい場合
            // return "PARAM1 = " + PARAM1 + "\r\n" + "PARAM2 = " + PARAM2;
        }

        // 1ユニットの行動を決定する（必須）
        // なお，ここでもらった map オブジェクトはコピーされたものなので，どのように利用・変更しても問題ありません．
        public Action makeAction(Map map, int teamColor)
        {
            dev_num = 0;

            // make root node
            Game_Tree root = makeroot(map, teamColor);

            // search
            totalsim = 0;

            basemap = map;

            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();

            for (int i = 0; i < MAX_SIM; i++)
            {
                //Logger.addLogMessage(i + "\r\n");

                if (stopwatch.ElapsedMilliseconds > 5000)
                    break;

                search(root, teamColor);

                totalsim++;
            }

            stopwatch.Stop();
            Logger.addLogMessage("sim_time: " + stopwatch.ElapsedMilliseconds + "\r\n");
            stopwatch.Reset();

            Logger.addLogMessage("dev_num: " + dev_num + "\r\n");

            Logger.addLogMessage("tree depth: " + max_depth + " max: " + map.getUnitsList(teamColor, false, true, true).Count + "\r\n");
            //Logger.addLogMessage("sim num: " + totalsim + "\r\n");

            for (int i = 0; i < root.next.Count; i++)
            {
                Logger.addLogMessage(root.next[i].simnum + ", ");
            }

            Logger.addLogMessage("\r\n");

            // select return node
            int rtnID = 0;
            double maxhousyuu = 0;

            for (int i = 0; i < root.next.Count; i++)
            {
                Game_Tree rtnnode = root.next[i];
                double tmphousyuu = root.next[i].housyuu;
                if (tmphousyuu > maxhousyuu)
                {
                    maxhousyuu = tmphousyuu;
                    rtnID = i;
                }
            }

            return root.next[rtnID].act;
        }

        // root node 作成
        public static Game_Tree makeroot(Map map, int teamcolor)
        {
            Game_Tree root = new Game_Tree();
            root.board = map.createDeepClone();

            List<Action> allActions = new List<Action>(); // 全合法手
            List<Unit> allUnits = map.getUnitsList(teamcolor, false, true, false);  // 未行動自ユニット

            foreach (Unit u in allUnits)
            {
                List<Action> the_acts = AiTools.getUnitActions(u, map); // 選択したユニットの全行動
                allActions.AddRange(the_acts);
            }

            root.kouho = allActions;
            
            // 2015_6_11　必要ないと判断してコメントアウト
            //allActions.ElementAt(0); // ←これ必要？

            foreach (Action act in allActions)
            {
                // ここで枝刈り（というか木に追加しない）する関数

                Game_Tree child = new Game_Tree();
                child.board = map.createDeepClone();
                child.act = act;
                child.depth = 1;
                child.board.executeAction(act);
                root.next.Add(child);
            }

            return root;
        }

        // 主探索部
        public static void search(Game_Tree n, int teamcolor)
        {

            if (totalsim == 0)
                max_depth = 0;

            if (n.depth > max_depth)
                max_depth = n.depth;


            int enemycolor = getenemycolor(teamcolor);

            double maxUCB = -1;
            int maxID = 0;
            for (int j = 0; j < n.next.Count; j++)
            {
                Game_Tree child = n.next[j];
                double tmpUCB = evaluateUCT(child);

                if (tmpUCB == 100) // simnum = 0
                {
                    maxUCB = tmpUCB;
                    maxID = j;
                    break;
                }

                if (tmpUCB > maxUCB)
                {
                    maxUCB = tmpUCB;
                    maxID = j;
                }
            }

            //Thread.Sleep(200);
            //Logger.addLogMessage(n.next[maxID].simnum + "\r\n");


            if (n.next[maxID].simnum > SIM_SIKI) // 展開閾値を超えている)
            {
                if (n.next[maxID].next.Count == 0) // 展開されてない
                {
                    if (n.next[maxID].board.getUnitsList(teamcolor, false, true, false).Count > 0) // 身行動自ユニットがいる
                    {
                        development(n.next[maxID], teamcolor);
                    }
                    else if (n.next[maxID].board.getUnitsList(enemycolor, false, true, false).Count > 0) // 身行動相手ユニットならいる
                    {
                        development(n.next[maxID], enemycolor);
                    }
                    else // 未行動ユニットが存在しない
                    {
                        // ユニットを全て未行動状態にして展開？
                        Logger.addLogMessage("all moved!\r\n");

                        // 2015_6_8 修正
                        n.next[maxID].board.enableUnitsAction(teamcolor);
                        n.next[maxID].board.enableUnitsAction(enemycolor);
                        development(n.next[maxID], teamcolor);
                    }
                }

                search(n.next[maxID], teamcolor);

                // 子ノードから返ってきた結果を反映させる
                n.next[maxID].simnum++;
                n.next[maxID].lastscore = n.next[maxID].next[lastid].lastscore;
                n.next[maxID].totalscore += n.next[maxID].lastscore;
                n.next[maxID].housyuu = n.next[maxID].totalscore / n.next[maxID].simnum;
                
                lastid = maxID;

            }
            else // 末端の葉ノード
            {
                // ランダムシミュレーション
                Map result = randomsimulation(n.next[maxID].board, teamcolor);

                //Logger.addLogMessage("simulate.\r\n");

                n.next[maxID].simnum++;
                n.next[maxID].lastscore = evaluateStateValue(result, teamcolor);
                n.next[maxID].totalscore += n.next[maxID].lastscore;
                n.next[maxID].housyuu = n.next[maxID].totalscore / n.next[maxID].simnum;

                lastid = maxID;

            }

        }


        //ランダムシミュレーション
        public static Map randomsimulation(Map map, int teamcolor)
        {
            int enemycolor = getenemycolor(teamcolor);

            Random fRand = new Random();

            Map simmap = map.createDeepClone();

            for (int d = 0; d < (simmap.getTurnLimit() - simmap.getTurnCount()) / 2; d++)
            {
                List<Unit> simUnits = simmap.getUnitsList(teamcolor, false, true, false);

                while (simUnits.Count > 0)
                {
                    Action simact;
                    if (fRand.NextDouble() >= 0.2 && AiTools.getAllAttackActions(teamcolor, simmap).Count > 0)
                    {
                        List<Action> simacts = AiTools.getAllAttackActions(teamcolor, simmap);
                        simact = simacts[fRand.Next(simacts.Count)];//ランダムに１つを選択

                    }
                    else
                    {
                        Unit simUnit = simUnits[fRand.Next(simUnits.Count)]; // ランダムに１つを選択
                        List<Action> simacts = AiTools.getUnitActions(simUnit, simmap);//選択したユニットの全行動
                        simact = simacts[fRand.Next(simacts.Count)];//ランダムに１つを選択
                    }

                    simmap.executeAction(simact);

                    simUnits = simmap.getUnitsList(teamcolor, false, true, false);  // 未行動自ユニット
                }

                simmap.enableUnitsAction(teamcolor);//活性化


                List<Unit> enemies = simmap.getUnitsList(enemycolor, false, true, false);  // 未行動敵リスト

                while (enemies.Count > 0)
                {
                    Action enact;
                    if (fRand.NextDouble() >= 0.2 && AiTools.getAllAttackActions(enemycolor, simmap).Count > 0)
                    {
                        List<Action> enacts = AiTools.getAllAttackActions(enemycolor, simmap);
                        enact = enacts[fRand.Next(enacts.Count)];//ランダムに１つを選択

                    }
                    else
                    {
                        Unit enUnit = enemies[fRand.Next(enemies.Count)];//ランダムに１つを選択
                        List<Action> enacts = AiTools.getUnitActions(enUnit, simmap);//選択したユニットの全行動
                        enact = enacts[fRand.Next(enacts.Count)];//ランダムに１つを選択
                    }

                    simmap.executeAction(enact);

                    enemies = simmap.getUnitsList(enemycolor, false, true, false);  // 全ての敵リスト
                }

                simmap.enableUnitsAction(enemycolor);//活性化


                if (simmap.getUnitsList(teamcolor, true, true, false).Count == 0 || simmap.getUnitsList(teamcolor, false, false, true).Count == 0)
                    break;

            }

            return simmap;

        }

        // ノードの展開
        public static void development(Game_Tree n, int teamcolor)
        {
            dev_num++;

            List<Action> allActions = new List<Action>();
            List<Unit> allUnits = n.board.getUnitsList(teamcolor, false, true, false);  // 未行動自ユニット

            foreach (Unit u in allUnits)
            {
                List<Action> the_acts = AiTools.getUnitActions(u, n.board);//選択したユニットの全行動
                allActions.AddRange(the_acts);
            }

            foreach (Action act in allActions)
            {
                // ここで枝刈り（というか木に追加しない）する関数

                Game_Tree child = new Game_Tree();
                child.board = n.board.createDeepClone();
                child.act = act;
                child.depth = n.depth + 1;
                child.board.executeAction(act);
                n.next.Add(child);
            }

        }

        //UCB値計算
        public static double evaluateUCT(Game_Tree n)
        {
            if (n.simnum == 0)
                return 100;
            else
                return n.housyuu + UCB_CONST * Math.Sqrt(Math.Log(totalsim, Math.E) / n.simnum);
        }

        //状態評価関数(シミュレーション後)    return 1, 0.5, or 0
        public static double evaluateStateValue(Map map, int teamcolor)
        {
            int enemycolor = getenemycolor(teamcolor);

            List<Unit> myTeamUnits = map.getUnitsList(teamcolor, true, true, false);//自分チームの全てのユニット
            List<Unit> enemyTeamUnits = map.getUnitsList(enemycolor, true, true, false);//相手チームの全てのユニット

            if (myTeamUnits.Count == 0)
                return 0;
            if (enemyTeamUnits.Count == 0)
                return 1;

            double mytotalHP = 0;
            double enemytotalHP = 0;

            for (int i = 0; i < myTeamUnits.Count; i++)
                mytotalHP += myTeamUnits[i].getHP();

            for (int i = 0; i < enemyTeamUnits.Count; i++)
                enemytotalHP += enemyTeamUnits[i].getHP();

            if (mytotalHP - enemytotalHP >= map.getDrawHPThreshold())
                return 1;
            else if (Math.Abs(mytotalHP - enemytotalHP) < map.getDrawHPThreshold())
                return 0.5;
            else
                return 0;

        }

        // enemycolor定義
        public static int getenemycolor(int teamcolor)
        {
            if (teamcolor == 1)
                return 0;
            else
                return 1;
        }


    }

}
